/**
	roughly equalivent to scombinator!f = zip(r,r.map!f)
	
	.map!(a=>a.unpack) to discard the values generated by the map
	
	after much experimation, this cant be improved on thru meta programming... so the rest of the functions are manual implitations of what should be the main uses
	
*/

auto scombinator(alias F,R,A...)(R r,A args){
	static A args_;
	args_=args;
	struct scomb(T){
		T me;
		auto get(){
			return F(me,args_);
		}
		alias get this;
		auto opDispatch(string name,T...)(T vals){
			mixin("return "~name~"(F(me,args),vals);");
		}
		auto ref unpack(){
			return me;
		}
	}
	return r.map!(a=>scomb!(typeof(a))(a));
}

/**
	roughly equalivent to sfoldmap!h = zip(r,r.cumaltivefold!f).map!(_=>g(.1,.2)) when h=g(f)
	
	make sure to use ref parameters
*/

auto sfoldmap(alias F,R,A...)(R r,A args){
	struct map{
		R r;
		A args;
		typeof(r.front) store;
		bool write=true;
		auto front(){
			if(write){
				store=F(r.front,args);
			}
			write=false;
			return store;
		}
		void popFront(){r.popFront;write=true;}
		bool empty(){return r.empty;}
	}
	return map(r,args);
}

auto sfoldmapoutput(alias O,alias F,R,A...)(R r,A args){//BAD BAD BAD: god help me
	//copy of sfoldmap, cause I forgot these were monads and not magic in biuld.d, if I intend these to work this way it shouldnt be modified here(on a copypaste of a copypasted file) without unittests; oh and it should work on all inputs
	struct map{
		R r;
		A args;
		typeof(r.front) store;
		bool write=true;
		auto front(){
			if(write){
				store=F(r.front,args);
			}
			write=false;
			return store;
		}
		void popFront(){r.popFront;write=true;}
		bool empty(){
			if(r.empty){
				O=args[0];
			}
			return r.empty;
		}
	}
	return map(r,args);
}

/**
	roughly equalivent to s_split!f = zip(r,cumaltivefold!f).splitWhen(_=>.2).map!(_=>.1)
	
*/
auto s_split(alias F,R,A...)(R r,A args){
	struct split_{
		R r;
		A args;
		bool split=false;
		void pop(){
			if(!empty){
				split=F(r.front,args);}}
		struct splitchild{//TODO: make a real implimetion
			split_* parent;
			ref split_ p(){return *parent;}
			auto front(){return p.r.front;}
			auto popFront(){
				if(empty){return;}
				p.r.popFront;
				if( ! p.r.empty){
					p.pop;}
			}
			bool empty(){
				return p.r.empty || p.split;}
		}
		auto front(){
			return splitchild(&this);
		}
		void popFront(){
			while( ! split && ! empty){
				r.popFront;
				pop;
			}
			if(empty){return;}
			r.popFront;
			pop;
		}
		bool empty(){return r.empty;}
	}
	return split_(r,args);
}
/**
	s_sort!f=zip(r,r.map!f).sort!(a,b=>a._1<b._2).map!(_=>.1)
*/
import std.algorithm.sorting : schwartzSort;
alias s_sort=schwartzSort;

/**
	roughly equalivent to ... nothing in the std; single iteration radix sort
*/

